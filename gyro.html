<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>The Reconception of Chicago Public Schools</title>
		<style>
			body { margin: 0; }
			canvas { display: block; }
            
            #overlay {
                position: absolute;
                z-index: 2;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
                opacity: 1;
                background-color: #000000;
                color: #ffffff;
            }
            
            #overlay > div {
                text-align: center;
            }
            
            #overlay > div > button {
                height: 20px;
                background: transparent;
                color: #ffffff;
                outline: 1px solid #ffffff;
                border: 0px;
                cursor: pointer;
            }

            a, button, input, select {
                pointer-events: auto;
            }
            button {
                cursor: pointer;
                text-transform: uppercase;
            }
            
            #overlay > div > p {
                color: #777777;
                font-size: 12px;
            }
		</style>
	</head>
	<body>
        <div id="overlay">
			<div>
				<button id="startButton">Start Demo</button>
				<p>Using device orientation might require a user interaction.</p>
			</div>
		</div>
		<script type="module">
            
            import * as THREE from './three/build/three.module.js';

			import { DeviceOrientationControls } from './three/examples/jsm/controls/DeviceOrientationControls.js';
            
            
            // obj - your object (THREE.Object3D or derived)
            // point - the point of rotation (THREE.Vector3)
            // axis - the axis of rotation (normalized THREE.Vector3)
            // theta - radian value of rotation
            // pointIsWorld - boolean indicating the point is in world coordinates (default = false)
            function rotateAboutPoint(obj, point, axis, theta, pointIsWorld) {
                pointIsWorld = (pointIsWorld === undefined)? false : pointIsWorld;

                if(pointIsWorld){
                    obj.parent.localToWorld(obj.position); // compensate for world coordinate
                }

                obj.position.sub(point); // remove the offset
                obj.position.applyAxisAngle(axis, theta); // rotate the POSITION
                obj.position.add(point); // re-add the offset

                if(pointIsWorld){
                    obj.parent.worldToLocal(obj.position); // undo world coordinates compensation
                }

                obj.rotateOnAxis(axis, theta); // rotate the OBJECT
            }
            
            var startButton = document.getElementById( 'startButton' );
			startButton.addEventListener( 'click', function () {
				init();
				animate();

			}, false );
            
            var camera, scene, renderer, controls;
            
            function init() {
                
                var overlay = document.getElementById( 'overlay' );
				overlay.remove();
            
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0xffffff);
                camera = new THREE.PerspectiveCamera( 20, window.innerWidth/window.innerHeight, 0.1, 1000 );
                camera.target = new THREE.Vector3( 0, 0, 0 );

                controls = new DeviceOrientationControls( camera );

                renderer = new THREE.WebGLRenderer();
                renderer.setSize( window.innerWidth, window.innerHeight );
                document.body.appendChild( renderer.domElement );

                var geometry = new THREE.BoxGeometry(1.25, 1, 0.001);


                function addRect(material) {
                    return new THREE.Mesh( geometry, material );
                }

                function addImage(finished) {

                    new THREE.ImageLoader()
                        .setCrossOrigin( '*' )
                        .load( 'img/test1.jpg?' + performance.now(), function ( image ) {

                            let texture = new THREE.CanvasTexture(image, 
                                                                  THREE.UVMapping, 
                                                                  THREE.ClampToEdgeWrapping, THREE.ClampToEdgeWrapping,
                                                                  THREE.LinearFilter,
                                                                  THREE.LinearMipmapLinearFilter,
                                                                  THREE.RGBAFormat,
                                                                  THREE.UnsignedByteType,
                                                                  renderer.getMaxAnisotropy());
                            let material = new THREE.MeshBasicMaterial( { color: 0xffffff, map: texture } );
                            let obj = addRect( material );
                            finished(obj)
                        } );

                }

                var cubes = [];

                for(let i = 0; i < 3; i++) {
                    addImage(function(obj) {
                        cubes[i] = obj;

                        scene.add( cubes[i] );
                        cubes[i].position.z = -5;

                        let div = 5;

                        rotateAboutPoint(cubes[i], new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 1, 0 ), (Math.PI / div)  - i * (Math.PI / div), false);
                    });
                }
                
            }
            
            var isUserInteracting = true,
				onMouseDownMouseX = window.innerWidth / 2, 
                onMouseDownMouseY = window.innerHeight / 2,
				lon = 0, onMouseDownLon = 0,
				lat = 0, onMouseDownLat = 0,
				phi = 0, theta = 0,
                sens = -0.07;
            
            //document.addEventListener( 'mousedown', onPointerStart, false );
            document.addEventListener( 'mousemove', onPointerMove, false );
            //document.addEventListener( 'mouseup', onPointerUp, false );

            document.addEventListener( 'wheel', onDocumentMouseWheel, false );

            //document.addEventListener( 'touchstart', onPointerStart, false );
            document.addEventListener( 'touchmove', onPointerMove, false );
            //document.addEventListener( 'touchend', onPointerUp, false );
            
            window.addEventListener( 'resize', onWindowResize, false );

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}
            
            
            function onPointerStart( event ) {

				isUserInteracting = true;

				var clientX = event.clientX || event.touches[ 0 ].clientX;
				var clientY = event.clientY || event.touches[ 0 ].clientY;

				onMouseDownMouseX = clientX;
				onMouseDownMouseY = clientY;

				onMouseDownLon = lon;
				onMouseDownLat = lat;

			}

			function onPointerMove( event ) {

				if ( isUserInteracting === true ) {

					var clientX = event.clientX || event.touches[ 0 ].clientX;
					var clientY = event.clientY || event.touches[ 0 ].clientY;

					lon = ( onMouseDownMouseX - clientX ) * sens + onMouseDownLon;
					lat = ( clientY - onMouseDownMouseY ) * sens + onMouseDownLat;

				}

			}

			function onPointerUp() {

				isUserInteracting = false;

			}

			function onDocumentMouseWheel( event ) {

				var fov = camera.fov + event.deltaY * 0.05;

				camera.fov = THREE.MathUtils.clamp( fov, 10, 75 );

				camera.updateProjectionMatrix();

			}
            
            

			var animate = function () {
				requestAnimationFrame( animate );
                

				update();
			};
            
            
            function update() {

				lat = Math.max( - 85, Math.min( 85, lat ) );
				phi = THREE.MathUtils.degToRad( 90 - lat );
				theta = THREE.MathUtils.degToRad( lon );

				camera.target.x = 500 * Math.sin( phi ) * Math.cos( theta );
				camera.target.y = 500 * Math.cos( phi );
				camera.target.z = 500 * Math.sin( phi ) * Math.sin( theta );

				camera.lookAt( camera.target );
                
                controls.update();

				/*
				// distortion
				camera.position.copy( camera.target ).negate();
				*/

				renderer.render( scene, camera );

			}
        </script>
	</body>
</html>